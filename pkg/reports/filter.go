/*******************************************************************************
*
* Copyright 2017 SAP SE
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You should have received a copy of the License along with this
* program. If not, you may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*******************************************************************************/

package reports

import (
	"net/http"
	"regexp"

	"github.com/sapcc/limes/pkg/db"
)

//Filter describes query parameters that can be sent to various GET endpoints
//to filter the reports generated by this package.
type Filter struct {
	serviceTypes  []string
	resourceNames []string
}

//ReadFilter extracts a Filter from the given Request.
func ReadFilter(r *http.Request) Filter {
	var (
		f  Filter
		ok bool
	)
	queryValues := r.URL.Query()
	if f.serviceTypes, ok = queryValues["service"]; !ok {
		f.serviceTypes = nil
	}
	if f.resourceNames, ok = queryValues["resource"]; !ok {
		f.resourceNames = nil
	}
	return f
}

var filterPrepareRx = regexp.MustCompile(`{{AND ([a-z.]+) = \$(service_type|resource_name)}}`)

//PrepareQuery takes a SQL query string, and replaces the following
//placeholders with the values in this Filter:
//
//    {{AND some_table.some_field = $service_type}}
//    {{AND some_table.some_field = $resource_name}}
func (f Filter) PrepareQuery(query string) (preparedQuery string, args []interface{}) {
	preparedQuery = filterPrepareRx.ReplaceAllStringFunc(query, func(matchStr string) string {
		match := filterPrepareRx.FindStringSubmatch(matchStr)
		values := f.serviceTypes
		if match[2] == "resource_name" {
			values = f.resourceNames
		}

		if len(values) == 0 {
			return ""
		}

		whereStr, queryArgs := db.BuildSimpleWhereClause(map[string]interface{}{match[1]: values}, len(args))
		args = append(args, queryArgs...)
		return "AND " + whereStr
	})

	return
}
